(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{75:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"metadata",(function(){return s})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return b}));var n=a(1),r=a(6),i=(a(0),a(86)),c={title:"Pattern Matching"},s={unversionedId:"docs-pattern_matching",id:"docs-pattern_matching",isDocsHomePage:!1,title:"Pattern Matching",description:"Pattern matching is one of the most powerful concepts in Tony. It makes it possible to write very succinct and readable code and plays particularly nicely with Tony's focus on recursion.",source:"@site/docs/docs-pattern_matching.md",slug:"/docs-pattern_matching",permalink:"/docs/docs-pattern_matching",editUrl:"https://github.com/tony-lang/tony-lang.github.io/edit/master/docs/docs-pattern_matching.md",version:"current",sidebar:"docs",previous:{title:"List Comprehensions",permalink:"/docs/docs-list_comprehensions"},next:{title:"Conditionals",permalink:"/docs/docs-conditionals"}},l=[{value:"Destructuring Lists &amp; Tuples",id:"destructuring-lists--tuples",children:[]},{value:"Destructuring Maps",id:"destructuring-maps",children:[]},{value:"Rest pattern",id:"rest-pattern",children:[]},{value:"Default values",id:"default-values",children:[]},{value:"Abstractions",id:"abstractions",children:[{value:"Abstraction Branches",id:"abstraction-branches",children:[]}]},{value:"Properties",id:"properties",children:[]}],o={rightToc:l};function b(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},o,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Pattern matching is one of the most powerful concepts in Tony. It makes it possible to write very succinct and readable code and plays particularly nicely with Tony's focus on recursion."),Object(i.b)("p",null,"A pattern in Tony can either be"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"a ",Object(i.b)("em",{parentName:"li"},"destructuring pattern")," (i.e. a list, tuple or map pattern) that contains other patterns;"),Object(i.b)("li",{parentName:"ul"},"a ",Object(i.b)("em",{parentName:"li"},"literal")," that is matched agains the assigned value; or"),Object(i.b)("li",{parentName:"ul"},"an ",Object(i.b)("em",{parentName:"li"},"identifier")," that is defined with the assigned value.")),Object(i.b)("h2",{id:"destructuring-lists--tuples"},"Destructuring Lists & Tuples"),Object(i.b)("p",null,"Lists and tuples can be destructured/pattern matched as follows:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-tn"}),"# a := 1, b := [3, 4, 5]\n[0, a, 2, ...b] := [0, 1, 2, 3, 4, 5]\n\n# throws an error\n[1, 2, ...a] := [0, 1, 2, 3]\n\n# a := 'hello', b := (2, 'Tony')\n[(1, a), b] := [(1, 'hello'), (2, 'Tony')]\n")),Object(i.b)("h2",{id:"destructuring-maps"},"Destructuring Maps"),Object(i.b)("p",null,"Maps can be pattern matched in this way:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-tn"}),"# a := 1, b := 2, d := {'d' -> 4}\n{ 'key' -> a, b, 'c' -> 3, ...d } := { 'key' -> 1, 'b' -> 2, 'c' -> 3, 'd' -> 4 }\n")),Object(i.b)("h2",{id:"rest-pattern"},"Rest pattern"),Object(i.b)("p",null,"As shown in the examples above, the rest pattern ",Object(i.b)("inlineCode",{parentName:"p"},"...")," can be used to pack remaining unmatched values, into a data structure. Rest patterns may only be used as the last pattern within a list, tuple or map pattern."),Object(i.b)("h2",{id:"default-values"},"Default values"),Object(i.b)("p",null,"Identifiers within patterns may have a default value:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-tn"}),"# a := 0, b := 1\n[a, b = 1] := [0]\n\n# a := 1, b := 2, c := 0\n{ a, b = 100, c = 0 } := { 'a' -> 1, 'b' -> 2 }\n")),Object(i.b)("h2",{id:"abstractions"},"Abstractions"),Object(i.b)("p",null,"The important thing to wrap your head around when working with Tony is that parameters are nothing more than a tuple pattern.\nThis means that your abstractions can also benefit from pattern matching with literals, rest patterns, and default values."),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"An important difference to pattern matching in assignments is that if a pattern is not large enough to capture an argument, it does not match:"),Object(i.b)("pre",{parentName:"div"},Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-tn"}),"# this pattern matches, a := 2, b := 3, c := 4\n(1, a, b, c) := (1, 2, 3, 4, 5)\n\n# this pattern does not match, throws an error\n((1, a, b, c) => (a, b, c))(1, 2, 3, 4, 5)\n\n# this pattern does match, returns (2, 3, (4, 5))\n((1, a, b, ...c) => (a, b, c))(1, 2, 3, 4, 5)\n")))),Object(i.b)("h3",{id:"abstraction-branches"},"Abstraction Branches"),Object(i.b)("p",null,"Tony allows you specify multiple patterns for a single abstraction where each of them have a different abstraction body, they are called ",Object(i.b)("em",{parentName:"p"},"branches"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-tn"}),"fn := (0) => 1, (x) => x\nfn(0) # returns 1\nfn(1) # returns 1\n")),Object(i.b)("p",null,"All abstractions we have seen previously were abstractions with just a single branch."),Object(i.b)("p",null,"When implementing recursion, one or more base cases are separated from the recursive step. As Tony supports pattern matching, this separation of multiple cases is very natural and easy to follow. Take a look at the following implementation of the Fibonacci sequence:"),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-tn"}),"+ := (a, b) => eval('{a} + {b}')\n- := (a, b) => eval('{a} - {b}')\n\nfib :=\n  (0) => 0\n  (1) => 1\n  (n) => fib(n - 1) + fib(n - 2)\n")),Object(i.b)("h4",{id:"example-quicksort"},"Example: Quicksort"),Object(i.b)("p",null,Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Quicksort"}),"Quicksort")," is a sorting algorithm devloped by Tony Hoare that on average terminates in polynomial time."),Object(i.b)("p",null,"Through the use of pattern matching, Quicksort can be implemented in Tony in a very reduced and readable fashion."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-tn"}),"+ := (a, b) => eval('[{a}].concat([{b}])')\n<= := (a, b) => eval('{a} <= {b}')\n> := (a, b) => eval('{a} > {b}')\n\nquicksort :=\n  ([]) => []\n  ([pivot, ...rest]) =>\n    l := quicksort([n | n in rest if n <= pivot])\n    r := quicksort([n | n in rest if n > pivot])\n    l + [pivot] + r\n")),Object(i.b)("p",null,"Different from implementations in most other programming languages, this implementation preserves the characteristic features of the algorithm such as choosing a pivot element and then separately sorting smaller and larger elements."),Object(i.b)("h2",{id:"properties"},"Properties"),Object(i.b)("p",null,"There are minor differences in the behavior of pattern matching depending on the area in which it is used.\nNamely, there are two properties signifying those differences:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("em",{parentName:"li"},"partially matching")," - pattern matching is still successful when all arguments are matched, but only some elements of the pattern (i.e. the pattern is larger than the provided value)"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("em",{parentName:"li"},"overmatching")," - pattern matching is still successful when all elements of the pattern are matched, but only some of the arguments (i.e. the provided value is larger than the pattern)")),Object(i.b)("p",null,"Here is how those properties are distributed among applications of pattern matching:"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null})),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"partially matching"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:null}),"overmatching"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"assignment"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"\u274c"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"\u2714\ufe0f")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"abstraction"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"\u2714\ufe0f in depth ",Object(i.b)("inlineCode",{parentName:"td"},"1")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"\u274c")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"/docs/docs-case"}),"case")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"\u274c"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:null}),"\u274c")))))}b.isMDXComponent=!0},86:function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return d}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function c(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?c(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):c(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=r.a.createContext({}),b=function(e){var t=r.a.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=b(e.components);return r.a.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,c=e.parentName,o=l(e,["components","mdxType","originalType","parentName"]),p=b(a),m=n,d=p["".concat(c,".").concat(m)]||p[m]||u[m]||i;return a?r.a.createElement(d,s(s({ref:t},o),{},{components:a})):r.a.createElement(d,s({ref:t},o))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,c=new Array(i);c[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:n,c[1]=s;for(var o=2;o<i;o++)c[o]=a[o];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);