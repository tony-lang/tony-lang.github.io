(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{76:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return u}));var a=n(1),o=n(6),r=(n(0),n(86)),i={title:"Introduction"},s={unversionedId:"docs-introduction",id:"docs-introduction",isDocsHomePage:!1,title:"Introduction",description:"A program structures the flow of data in memory. We often write functions to extract fragments from this manipulation of data and make them reusable. Tony reduces the idea of a program to that fundamental core, but adds some ideas that make these programs easier to reason about. Those ideas will be discussed in the following document.",source:"@site/docs/docs-introduction.md",slug:"/docs-introduction",permalink:"/docs/docs-introduction",editUrl:"https://github.com/tony-lang/tony-lang.github.io/edit/master/docs/docs-introduction.md",version:"current",sidebar:"docs",next:{title:"Abstraction & Application",permalink:"/docs/docs-abstraction_application"}},c=[{value:"Abstraction &amp; Application",id:"abstraction--application",children:[]},{value:"Immutability",id:"immutability",children:[]},{value:"Expressions",id:"expressions",children:[]},{value:"Recursion",id:"recursion",children:[]}],l={rightToc:c};function u(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"A program structures the flow of data in memory. We often write functions to extract fragments from this manipulation of data and make them reusable. Tony reduces the idea of a program to that fundamental core, but adds some ideas that make these programs easier to reason about. Those ideas will be discussed in the following document."),Object(r.b)("h2",{id:"abstraction--application"},"Abstraction & Application"),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Lambda_calculus"}),"Lambda calculus")," is a theory devised by the mathematician Alonzo Church that can be used to model computation. The concepts introduced by lambda calculus are also at the core of Tony's design.\nLambda calculus introduces the notion of ",Object(r.b)("strong",{parentName:"p"},"abstraction"),", which is similar to a ",Object(r.b)("em",{parentName:"p"},"function")," or ",Object(r.b)("em",{parentName:"p"},"closure"),", and ",Object(r.b)("strong",{parentName:"p"},"application"),", which describes ",Object(r.b)("em",{parentName:"p"},"calling a function"),". Tony borrows these terms, so don't be surprised when they come up again in this document."),Object(r.b)("p",null,"But Tony goes further than just renaming functions to abstractions and function calls to applications. These two concepts are at the foundation of everything else that you write in a Tony program. Most higher level concepts do nothing more than to hide the abstraction of reused fragments and their application behind a fancy syntax."),Object(r.b)("h2",{id:"immutability"},"Immutability"),Object(r.b)("p",null,"Using only the two concepts of ",Object(r.b)("em",{parentName:"p"},"abstraction")," and ",Object(r.b)("em",{parentName:"p"},"application"),", programs can become very confusing. This is because there is no way of actually storing an intermediate value or the abstraction of a value in memory to be accessed later. This is why Tony, and pretty much any other general purpose programming language for that matter, supports assignments."),Object(r.b)("p",null,"Without assignments an abstraction could not be used to reuse fragments of code, but only to delay its execution (until it is applied)."),Object(r.b)("p",null,"Other than in most other programming languages though, all assignments in Tony are immutable. That means once a value is assigned to a constant, the constant cannot be reassigned to yet another value. At a first glance that might seem like an unnecessary restriction, but there are many compelling reasons why enforcing immutability actually improves the readability, maintainability and safety of programs:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"in the most trivial case, immutability of values ensures that no value is overwritten accidentally at a later point in time."),Object(r.b)("li",{parentName:"ol"},"when applying an argument to an abstraction, you can be sure that the value of that argument is the exact same when the applied abstraction returns."),Object(r.b)("li",{parentName:"ol"},"in a concurrent context, the immutability of values prevents race conditions.")),Object(r.b)("p",null,"Somewhat unintuitively, states can still be expressed with immutable values. A common approach is to create a copy of the old value with the applied change. Through the use of Persistent Data Sctructure those copy operations can be virtually as efficient as mutating the original data structure."),Object(r.b)("h2",{id:"expressions"},"Expressions"),Object(r.b)("p",null,"In Tony everything you write in a program is or is part of an expression. An expression is any structure in your code code that returns a value (in contrast to a statement). Therefore, in Tony, every syntactic element (with the exception of imports and exports) return a value."),Object(r.b)("p",null,"This means, for example, that you don't need to explicitly return from abstractions or that you can easily assign the result of an ",Object(r.b)("inlineCode",{parentName:"p"},"if")," expression to a constant."),Object(r.b)("p",null,"You can always stop execution of the current block and return a value using ",Object(r.b)("inlineCode",{parentName:"p"},"return"),"."),Object(r.b)("h2",{id:"recursion"},"Recursion"),Object(r.b)("p",null,"Tony does not have any iterative loops. Instead, to achieve repeated computation, recursion is used. There are some good reasons for this limitation:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"recursion encourages the extraction of code fragments into abstractions, making code more readable"),Object(r.b)("li",{parentName:"ol"},"not supporting loops encourages the use of ranges and higher-order abstractions like ",Object(r.b)("inlineCode",{parentName:"li"},"map")," and ",Object(r.b)("inlineCode",{parentName:"li"},"reduce")," that are implemented recursively, also enhancing the readability of code")),Object(r.b)("p",null,"All loops can easily be transformed into tail recursive functions. Therefore, this syntactic limitation does not restrict expressiveness of programs written in Tony."))}u.isMDXComponent=!0},86:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),u=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},b=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(n),b=a,d=p["".concat(i,".").concat(b)]||p[b]||m[b]||r;return n?o.a.createElement(d,s(s({ref:t},l),{},{components:n})):o.a.createElement(d,s({ref:t},l))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=b;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);